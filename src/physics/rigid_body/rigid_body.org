#+TITLE: Rigid body physics and implementation in Prestige
#+AUTHOR: Dinesh A
#+EMAIL: adepu.dinesh.a@gmail.com

* Theory

** Introduction
   Taken from the following references [[http://matthias-mueller-fischer.ch/realtimephysics/coursenotes.pdf][matthias]].


* Implementation of 3d rigid body dynamics


** mod.rs
   :PROPERTIES:
   :header-args: :tangle mod.rs
   :END:

  #+BEGIN_SRC rust
pub mod equations;
  #+END_SRC

  Create basic rigid body =struct= and implement useful traits.

  #+BEGIN_SRC rust
use cgmath::{Matrix3, Vector3};
use cgmath::prelude::*;
use std::collections::HashMap;

// import to implement this trait for nnps functionality
use crate::contact_search::GetXYZH;
use crate::WriteOutput;

// std library imports
use std::path::PathBuf;

// io library
use vtkio::export_ascii;
use vtkio::model::*;

pub struct RB3d {
    pub x: Vec<f32>,
    pub y: Vec<f32>,
    pub z: Vec<f32>,
    pub x0: Vec<f32>,
    pub y0: Vec<f32>,
    pub z0: Vec<f32>,
    pub u: Vec<f32>,
    pub v: Vec<f32>,
    pub w: Vec<f32>,
    pub u0: Vec<f32>,
    pub v0: Vec<f32>,
    pub w0: Vec<f32>,
    pub h: Vec<f32>,
    pub m: Vec<f32>,
    pub fx: Vec<f32>,
    pub fy: Vec<f32>,
    pub fz: Vec<f32>,
    pub rad: Vec<f32>,
    pub r_dash: Vec<Vector3<f32>>,
    pub r_dash0: Vec<Vector3<f32>>,
    pub r_body: Vec<Vector3<f32>>,
    pub cm: Vector3<f32>,
    pub lin_vel: Vector3<f32>,
    pub ang_vel: Vector3<f32>,
    pub lin_mom: Vector3<f32>,
    pub ang_mom: Vector3<f32>,
    pub torque: Vector3<f32>,
    pub net_force: Vector3<f32>,
    pub orientation: Matrix3<f32>,
    pub orientation_rate: Matrix3<f32>,
    pub moi_body_inv: Matrix3<f32>,
    pub moi_global_inv: Matrix3<f32>,
    pub total_mass: f32,
    pub nnps_idx: usize,
}

impl RB3d {
    /// Creates a DEMLinear entity from x, y, z and radius of given particles
    pub fn from_xyzr(x: Vec<f32>, y: Vec<f32>, z: Vec<f32>, rad: Vec<f32>) -> RB3d {
        RB3d {
            x: x.clone(),
            y: y,
            z: z,
            rad: rad,
            x0: vec![0.; x.len()],
            y0: vec![0.; x.len()],
            z0: vec![0.; x.len()],
            u: vec![0.; x.len()],
            v: vec![0.; x.len()],
            w: vec![0.; x.len()],
            u0: vec![0.; x.len()],
            v0: vec![0.; x.len()],
            w0: vec![0.; x.len()],
            h: vec![0.; x.len()],
            m: vec![0.; x.len()],
            fx: vec![0.; x.len()],
            fy: vec![0.; x.len()],
            fz: vec![0.; x.len()],
            r_dash: vec![Vector3::zero(); x.len()],
            r_dash0: vec![Vector3::zero(); x.len()],
            r_body: vec![Vector3::zero(); x.len()],
            cm: Vector3::new(0., 0., 0.),
            lin_vel: Vector3::new(0., 0., 0.),
            ang_vel: Vector3::new(0., 0., 0.),
            lin_mom: Vector3::new(0., 0., 0.),
            ang_mom: Vector3::new(0., 0., 0.),
            torque: Vector3::new(0., 0., 0.),
            net_force: Vector3::new(0., 0., 0.),
            orientation: Matrix3::new(1., 0., 0., 0., 1., 0., 0., 0., 1.),
            orientation_rate: Matrix3::<f32>::zero(),
            moi_body_inv: Matrix3::<f32>::zero(),
            moi_global_inv: Matrix3::<f32>::zero(),
            total_mass: 0.,
            nnps_idx: 0,
        }
    }

    pub fn from_xyr(x: Vec<f32>, y: Vec<f32>, rad: Vec<f32>) -> RB3d {
        RB3d::from_xyzr(x, y, vec![0.; rad.len()], rad)
    }
}

impl WriteOutput for RB3d {
    fn write_vtk(&self, output: String) {
        let x = &self.x;
        let y = &self.y;
        let z = &self.z;
        let u = &self.u;
        let v = &self.v;
        let w = &self.w;
        let fx = &self.fx;
        let fy = &self.fy;
        let fz = &self.fz;

        let mut pos = vec![];
        let mut vel = vec![];
        let mut forces = vec![];
        let mut h = vec![];
        let mut m = vec![];
        for i in 0..x.len() {
            pos.push(x[i]);
            pos.push(y[i]);
            pos.push(z[i]);
            vel.push(u[i]);
            vel.push(v[i]);
            vel.push(w[i]);
            forces.push(fx[i]);
            forces.push(fy[i]);
            forces.push(fz[i]);
            h.push(self.h[i]);
            m.push(self.m[i]);
        }

        let mut attributes = Attributes::new();
        attributes.point.push((
            "Forces".to_string(),
            Attribute::Vectors {
                data: forces.into(),
            },
        ));
        attributes.point.push((
            "Velocity".to_string(),
            Attribute::Vectors { data: vel.into() },
        ));

        attributes.point.push((
            "h".to_string(),
            Attribute::Scalars {
                num_comp: 1,
                lookup_table: None,
                data: h.into(),
            },
        ));

        attributes.point.push((
            "m".to_string(),
            Attribute::Scalars {
                num_comp: 1,
                lookup_table: None,
                data: m.into(),
            },
        ));

        let data = DataSet::UnstructuredGrid {
            points: pos.into(),
            cells: Cells {
                num_cells: 0,
                vertices: vec![],
            },
            cell_types: vec![],
            data: attributes,
        };

        let vtk = Vtk {
            version: Version::new((4, 1)),
            title: String::from("Data"),
            data: data,
        };

        let _p = export_ascii(vtk, &PathBuf::from(&output));
    }
}

// implement nnps macro
impl_GetXYZH!(RB3d);
  #+END_SRC


** equations.rs
   :PROPERTIES:
   :header-args: :tangle equations.rs
   :END:

   #+BEGIN_SRC rust
use super::RB3d;
use crate::contact_search::{NNPS, get_neighbours_1d, get_neighbours_2d, get_neighbours_3d};
use crate::{EulerIntegrator, RK2Integrator};
use cgmath::prelude::*;
use cgmath::Matrix3;
use cgmath::Vector3;
use rayon::prelude::*;

impl RB3d {
    /// compute total mass
    /// *Note*: This will be called while computing center of mass
    pub fn compute_total_mass(&mut self) {
        let mut tm = 0.;
        for i in 0..self.x.len() {
            tm += self.m[i];
        }

        self.total_mass = tm;
    }

    /// compute center of mass
    pub fn compute_center_of_mass(&mut self) {
        let mut cm = Vector3::zero();
        for i in 0..self.x.len() {
            cm[0] += self.m[i] * self.x[i];
            cm[1] += self.m[i] * self.y[i];
            cm[2] += self.m[i] * self.z[i];
        }
        self.cm = cm / self.total_mass;
    }
    /// compute Moment of inertia tensor
    /// Refer http://www.kwon3d.com/theory/moi/iten.html
    pub fn compute_moment_of_inertia(&mut self) {
        // set the orientation of the body
        self.orientation = Matrix3::new(1., 0., 0., 0., 1., 0., 0., 0., 1.);
        let x = &self.x;
        let y = &self.y;
        let z = &self.z;
        let m = &self.m;
        let mut moi = Matrix3::zero();
        let mut i_xx = 0.;
        let mut i_yy = 0.;
        let mut i_zz = 0.;
        let mut i_xy = 0.;
        let mut i_xz = 0.;
        let mut i_yz = 0.;
        let i_yx;
        let i_zx;
        let i_zy;
        let mut xi;
        let mut yi;
        let mut zi;
        let mut mi;

        for i in 0..self.x.len() {
            xi = x[i] - self.cm[0];
            yi = y[i] - self.cm[1];
            zi = z[i] - self.cm[2];
            mi = m[i];
            i_xx += mi * (yi.powf(2.) + zi.powf(2.));
            i_yy += mi * (xi.powf(2.) + zi.powf(2.));
            i_zz += mi * (xi.powf(2.) + yi.powf(2.));
            i_xy += -mi * xi * yi;
            i_xz += -mi * xi * zi;
            i_yz += -mi * yi * zi;
        }
        // set the symmetric terms
        i_yx = i_xy;
        i_zx = i_xz;
        i_zy = i_yz;

        // set the moment of inertia. The matrix3 is in column major order
        // set the first column
        moi[0] = Vector3::new(i_xx, i_yx, i_zx);
        moi[1] = Vector3::new(i_xy, i_yy, i_zy);
        moi[2] = Vector3::new(i_xz, i_yz, i_zz);

        // find the inverse
        self.moi_body_inv = moi.invert().unwrap();
        self.moi_global_inv = self.orientation * moi.invert().unwrap();
    }

    pub fn save_initial_position_vectors(&mut self) {
        for i in 0..self.x.len() {
            self.r_body[i] = Vector3::new(
                self.x[i] - self.cm[0],
                self.y[i] - self.cm[1],
                self.z[i] - self.cm[2],
            );
        }
        self.r_dash = self.r_body.clone();
        self.r_dash0 = self.r_body.clone();
    }

    pub fn update_ang_vel(&mut self) {
        self.ang_vel = self.moi_global_inv * self.ang_mom;
    }

    pub fn initialize(&mut self) {
        // compute total mass
        self.compute_total_mass();
        // compute center of mass
        self.compute_center_of_mass();
        // compute center of mass
        self.compute_moment_of_inertia();
        // save the body coordinate system position vectors
        self.save_initial_position_vectors();
    }
}

pub fn apply_gravity(
    d_m: &[f32], d_fx: &mut [f32], d_fy: &mut [f32], d_fz: &mut [f32],
    gx: f32, gy: f32, gz: f32,

) {
    for i in 0..d_fx.len(){
        d_fx[i] = gx * d_m[i];
        d_fy[i] = gy * d_m[i];
        d_fz[i] = gz * d_m[i];
    }
}

pub fn linear_interparticle_force(
    d_x: &[f32], d_y: &[f32], d_z: &[f32], d_u: &[f32],
    d_v: &[f32], d_w: &[f32], d_rad: &[f32], d_fx: &mut [f32],
    d_fy: &mut [f32], d_fz: &mut [f32],

    s_x: &[f32], s_y: &[f32], s_z: &[f32], s_u: &[f32],
    s_v: &[f32], s_w: &[f32], s_rad: &[f32], s_nnps_id: usize,

    nnps: &NNPS,
    k_n: f32,
    eta_n: f32,
) {
    d_fx.par_iter_mut()
        .zip(d_fy.par_iter_mut().zip(d_fz.par_iter_mut().enumerate()))
        .for_each(
            |(d_fx_i, (d_fy_i, (i, d_fz_i)))| {
                let mut xij = Vector3::new(0., 0., 0.);
                let mut nij;
                let mut vij: Vector3<f32> = Vector3::new(0., 0., 0.);
                let mut vij_n: Vector3<f32>;
                let mut fij_n = Vector3::new(0., 0., 0.);

                let mut rij;
                let mut overlap_n;
                let nbrs = match nnps.dim {
                    1 => get_neighbours_1d(d_x[i], d_y[i], d_z[i], s_nnps_id, &nnps),
                    2 => get_neighbours_2d(d_x[i], d_y[i], d_z[i], s_nnps_id, &nnps),
                    3 => get_neighbours_3d(d_x[i], d_y[i], d_z[i], s_nnps_id, &nnps),
                    _ => panic!("Dimensions are wrong"),
                };

                for &j in nbrs.iter() {
                    // Reset the forces for next contact
                    fij_n[0] = 0.;
                    fij_n[1] = 0.;
                    fij_n[2] = 0.;

                    xij[0] = s_x[j] - d_x[i];
                    xij[1] = s_y[j] - d_y[i];
                    xij[2] = s_z[j] - d_z[i];
                    rij = xij.magnitude();

                    // eliminate self interaction
                    if rij > 1e-12 {
                        // overlap amount
                        overlap_n = d_rad[i] + s_rad[j] - rij;
                        if overlap_n > 0. {
                            // normal vector from i to j
                            // Be careful about this
                            nij = xij / rij;

                            // Relative velocity particle i w.r.t j is uij
                            vij[0] = d_u[i] - s_u[j];
                            vij[1] = d_v[i] - s_v[j];
                            vij[2] = d_w[i] - s_w[j];

                            // normal velocity is
                            vij_n = vij.dot(nij) * nij;

                            // --------------------------------
                            // normal force due to the normal overlap
                            fij_n = -k_n * overlap_n * nij - eta_n * vij_n;

                            ,*d_fx_i += fij_n[0];
                            ,*d_fy_i += fij_n[1];
                            ,*d_fz_i += fij_n[2];
                        }
                    }
                }
            });
}

fn normalize_matrix3(mat: &mut Matrix3<f32>){
    // refer https://cg.informatik.uni-freiburg.de/course_notes/sim_06_rigidBodies.pdf
    let b1 = mat.x / mat.x.magnitude();
    let b2 = mat.y - b1.dot(mat.y) * b1;
    let b2 = b2 / b2.magnitude();
    let b3 = mat.z - b1.dot(mat.z) * b1 - b2.dot(mat.z) * b2;
    let b3 = b3 / b3.magnitude();
    // setup the normalized matrix
    mat.x = b1;
    mat.y = b2;
    mat.z = b3;
}

impl EulerIntegrator for RB3d {
    fn stage1(&mut self, dt: f32) {
        // aggregate all the forces to act at center of mass, and similar
        // way compute the torque
        let mut f = Vector3::zero();
        let mut fi;
        let mut trq = Vector3::zero();
        for i in 0..self.x.len() {
            fi = Vector3::new(self.fx[i], self.fy[i], self.fz[i]);
            f += fi;
            trq += self.r_dash[i].cross(fi);
        }
        // set the total force and torque
        self.net_force = f;
        self.torque = trq;
        // evolve the center of mass and center of mass velocity to next time step (t + dt)
        self.lin_vel += f * dt;
        self.cm += self.lin_vel * dt;
        // Evolve orientation to next time step (t + dt)
        self.orientation +=
            dt * Matrix3::new(
                // first column
                0.,
                self.ang_vel[2],
                -self.ang_vel[1],
                // second column
                -self.ang_vel[2],
                0.,
                self.ang_vel[0],
                // third column
                self.ang_vel[1],
                -self.ang_vel[0],
                0.,
            ) * self.orientation;
        // normalize the orientation matrix
        normalize_matrix3(&mut self.orientation);

        // update angular momentum
        self.ang_mom += dt * trq;

        // compute the moment of inertia at current time by using
        // angular momentum and rotation matrix at time t+dt
        self.moi_global_inv = self.orientation * self.moi_body_inv * self.orientation.transpose();

        // Update the angular velocity from the angular momentum at time
        // t + dt and the moi tensor at time t + dt
        self.ang_vel = self.moi_global_inv * self.ang_mom;

        // Update the position vectors from center of mass to the partices
        // r_dash
        let r_dash = &mut self.r_dash;
        let r_body = &self.r_body;
        for i in 0..self.x.len() {
            r_dash[i] = self.orientation * r_body[i];
            self.x[i] = self.cm[0] + r_dash[i][0];
            self.y[i] = self.cm[1] + r_dash[i][1];
            self.z[i] = self.cm[2] + r_dash[i][2];
            // velocity due to angular effect
            let tmp = self.ang_vel.cross(r_dash[i]);
            self.u[i] = self.lin_vel[0] + tmp[0];
            self.v[i] = self.lin_vel[1] + tmp[1];
            self.w[i] = self.lin_vel[2] + tmp[2];
        }
    }
}
   #+END_SRC



* Usage

** Example 1
   :PROPERTIES:
   :header-args: :tangle ../../../examples/rb_1.rs
   :END:
  #+BEGIN_SRC rust :tangle ../../../examples/rb_1.rs
extern crate prestige;
extern crate simple_shapes;
extern crate indicatif;

// crates imports
use prestige::{
    contact_search::{stash_3d, WorldBounds, NNPS},
    EulerIntegrator, WriteOutput,
    physics::rigid_body::{RB3d, equations::{linear_interparticle_force, apply_gravity}}
};

// external crate imports
use indicatif::{ProgressBar, ProgressStyle};
use simple_shapes::{grid_arange_3d, tank_3d};

// std imports
use std::fs;


fn create_entites(spacing : f32) -> (RB3d, RB3d){
    // Create the cube and the tank
    let (xc, yc, zc) = grid_arange_3d(1., 2., spacing, 0.5, 1.5, spacing, 1., 2., spacing);
    let rc = vec![spacing / 2.; xc.len()];
    let mut cube = RB3d::from_xyzr(xc.clone(), yc, zc, rc);
    let rho_c = 2000.;
    let mc = rho_c * spacing.powf(3.);
    cube.m = vec![mc; xc.len()];
    cube.nnps_idx = 0;
    let (xt, yt, zt) = tank_3d(-1.1, 3., spacing, -1.1, 3., spacing, -1., 3., spacing, 2);
    let rt = vec![spacing / 2.; xt.len()];
    let mut tank = RB3d::from_xyzr(xt.clone(), yt, zt, rt);
    let rho_t = 2000.;
    let mt = rho_t * spacing.powf(3.);
    tank.m = vec![mt; xt.len()];
    tank.nnps_idx = 1;

    // Compute the predefined quantities
    cube.initialize();
    tank.initialize();

    (cube, tank)
}

fn print_no_part(pars: Vec<&Vec<f32>>){
    let mut total_pars = 0;
    for x in pars{
        total_pars += x.len();
    }
    println!("Total particles {}", total_pars);
}


fn main() {
    let spacing = 0.1;
    // dimension
    let dim = 3;

    // particles
    let (mut body, tank) = create_entites(spacing);

    let kn = 1e5;

    print_no_part(vec![&body.x, &tank.x]);

    // setup nnps
    let world_bounds = WorldBounds::new(-1.1, 3.1, -1.1, 4.1, -1.0, 4.0, spacing);
    let mut nnps = NNPS::new(2, &world_bounds, dim);

    // solver data
    let dt = 1e-4;
    let mut t = 0.;
    let tf = 1.;
    let mut step_no = 0;
    let pfreq = 10;

    let project_root = env!("CARGO_MANIFEST_DIR");
    let dir_name = project_root.to_owned() + "/rb_1_output";
    let _p = fs::create_dir(&dir_name);

    // create a progress bar
    let total_steps = (tf / dt) as u64;
    let pb = ProgressBar::new(total_steps);
    pb.set_style(ProgressStyle::default_bar()
                 .template("{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] ({eta})")
                 .progress_chars("#>-"));
    while t < tf {
        // stash the particles into the world's cells
        stash_3d(vec![&body, &tank], &mut nnps);

        apply_gravity(&body.m, &mut body.fx, &mut body.fy, &mut body.fz, 0.0, -9.81, 0.0);
        linear_interparticle_force(
            &body.x, &body.y, &body.z,
            &body.u, &body.v, &body.w, &body.rad,
            &mut body.fx, &mut body.fy, &mut body.fz,

            &tank.x, &tank.y, &tank.z,
            &tank.u, &tank.v, &tank.w, &tank.rad, tank.nnps_idx,

            &nnps, kn, 5.
        );

        body.stage1(dt);

        if step_no % pfreq == 0 {
            tank.write_vtk(format!("{}/tank_{}.vtk", &dir_name, step_no));
            body.write_vtk(format!("{}/body_{}.vtk", &dir_name, step_no));
        }
        step_no += 1;
        t += dt;

        // progress bar increment
        pb.inc(1);
    }
    pb.finish_with_message("Simulation succesfully completed");
}
  #+END_SRC
